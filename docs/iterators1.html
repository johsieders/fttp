---

title: Title


keywords: fastai
sidebar: home_sidebar



nb_path: "nbs\01_iterators1.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs\01_iterators1.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Iterators-and-Iterables">Iterators and Iterables<a class="anchor-link" href="#Iterators-and-Iterables"> </a></h2><p>All Python collections are iterables, that is, you get an iterator by</p>

<pre><code>    xs = [1, 2, 3]
    t = iter(xs)

</code></pre>
<p>An iterator is a recipe for computing the next element. Its main operation is</p>

<pre><code>   next(t)
</code></pre>
<p>which applies the recipe and returns the next element. This works fine as long as there are elements left;
the fourth call in the example above would raise <code>StopIteration</code>. Each for-loop implicitly
applies <code>iter()</code> to what follows the in-clause:</p>

<pre><code>    for x in xs:
        for y in xs:
            print(x, y)

</code></pre>
<p>Here, Python creates two iterators on <code>xs</code>, being iterated on independently; the for-loop gracefully handles
<code>StopIteration</code>.</p>
<p>What is important:</p>
<ul>
<li>There can be any number of iterators on a given collection</li>
<li><p>Iterators are read-once; each <code>next</code> winds the iterator one notch down. There is no winding up.
Iterators can however be chained, like this:</p>

<pre><code>  s = chain([x], t)
</code></pre>
<p>creates a new iterator with <code>x</code> in front of <code>t</code>.</p>
</li>
<li><p>Iterators are lazy as opposed to lists which are eager. <em>Lazy</em> means, that elements are computed
not before they are need. This allows to manage infinite series.</p>
</li>
<li><p>Iterators are hard to debug. The <code>take</code>-function can be helpful. Good idea: Write a list-based version first and
convert to iterators later.</p>
</li>
</ul>
<p>The class <code>Iterator</code> in <code>Collections.abc</code> is an abstract base
class defining a single method <code>__next__()</code>. Iterators are ubiquitous but often invisible. They are created by
 <code>Iterables</code>, another abstract base class in <code>Collections.abc</code>.</p>
<p>An iterable is just an object which the iter-function accepts.
There are three ways to get one:</p>
<ol>
<li>applying <code>iter()</code>to a collection</li>
<li>writing a generator</li>
<li>overloading <code>__iter__</code></li>
</ol>
<p>We have seen the first way, let's turn to the second.</p>
<h3 id="Generators">Generators<a class="anchor-link" href="#Generators"> </a></h3><p>A generator is a function which
contains at least one <code>yield</code>-statement, such as this one:</p>

<pre><code>def naturals() -&gt; Iterator
    current = 0
    while True
        yield current
        current += 1

</code></pre>
<p>This generator would be used as follows:</p>

<pre><code>nat = naturals()
a = next(nat)
b = next(nat)

</code></pre>
<p>Here is how generators work: A call of <code>naturals()</code> produces a generator objet, <code>nat</code> in this case.
The code inside the function is executed until and excluding the first <code>yield</code>.
In the example above, <code>current</code> is set to 0, and generator is waiting for the first call of <code>next(nat)</code>.
On that call, the generator yields what it is supposed to and proceeds until and excluding the next <code>yield</code>:
<code>current</code>gets incremented, the while-loop restarts and stops. This can go on forever, but of course,
it normally doesn't. The good news is that generator gracefully handle infinity: <code>naturals()</code> delivers
an arbitrarily many natural numbers; there is to need to define an upper bound such as, say, 1e20.
It is up to the caller to call <code>next(nat)</code> as often as desired.</p>
<h3 id="Overloading-__iter__">Overloading <code>__iter__</code><a class="anchor-link" href="#Overloading-__iter__"> </a></h3><h2 id="ToDo">ToDo<a class="anchor-link" href="#ToDo"> </a></h2><h3 id="Iterators-and-Iterables">Iterators and Iterables<a class="anchor-link" href="#Iterators-and-Iterables"> </a></h3><p>Iterables produce Iterators via <code>iter()</code> such as all Collections.
Iterator yield the next element via <code>next()</code>. By convention, all Iterators
are also Iterables; the standard implementation being to return self.
Some examples:</p>
<ul>
<li><code>(0, 1, 2, 3)</code> is a tuple, no iterator</li>
<li><code>range(4)</code> is a tuple, no iterator</li>
<li><code>naturals()</code> is an iterator</li>
<li><code>(1 / k for k in naturals())</code> is an iterator</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Exercise-A">Exercise A<a class="anchor-link" href="#Exercise-A"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Write a function <code>naturals() -&gt; Iterator</code> which yields the natural numbers starting at 0.
Hint: Use <code>yield</code></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">naturals</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param start: an integer</span>
<span class="sd">    :return: the naturals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>faculty() -&gt; Iterator</code> which yields the factorials starting at 1.</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">faculty</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: un iterator yielding the factorials</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">current</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">current</span>
        <span class="n">current</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="n">factor</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>take(t: Iterator, n: int) -&gt; list</code> which returns a list of the first n elements of <code>t</code>.<ul>
<li>Hint: Use <code>islice()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param t: an iterator</span>
<span class="sd">    :param n: number of elements requested</span>
<span class="sd">    :return: list of first k elements with k = min(n, len(t))</span>
<span class="sd">    This avoids fiddling with StopIteration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>exp_taylor() -&gt; Iterator</code> which returns the Taylor series of the exponential function.<ul>
<li>Hint: use <code>faculty()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">exp_taylor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: iterator yielding the coefficients of the Taylor series of</span>
<span class="sd">    exp_taylor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">faculty</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>sin_taylor() -&gt; Iterator</code> which returns the Taylor series of sine.<ul>
<li>Hint: use <code>zip()</code> and <code>cycle()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">sin_taylor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: iterator yielding the coefficients of the Taylor series of sin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">exp_taylor</span><span class="p">()))</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>cos_taylor() -&gt; Iterator</code> which returns the Taylor series of cosine.<ul>
<li>Hint: use <code>zip()</code> and <code>cycle()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">cos_taylor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: iterator yielding the coefficients of the Taylor series of sin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cycle</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">exp_taylor</span><span class="p">()))</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Exercise-B">Exercise B<a class="anchor-link" href="#Exercise-B"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a recursive version of generator <code>naturals()</code>.<ul>
<li>Hint: Use <code>yield from</code>. What about the call stack?</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">naturals1</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param start: an integer</span>
<span class="sd">    :return: the naturals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">yield</span> <span class="n">start</span>
    <span class="k">yield from</span> <span class="n">naturals</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>fun(f: Callable, *args: any) -&gt; Iterator</code>.<ul>
<li>Here, <code>f</code> takes k arguments, e.g. k = 2, and k is the number of arguments given.</li>
<li><code>fun</code> returns <code>arg0, arg1, f(arg0, arg1), f(arg1, f(arg0, arg1)), ...</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">any</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param f: a function taking k arguments, e.g. k = 2</span>
<span class="sd">    :param args: k arguments accepted by f</span>
<span class="sd">    :return: n iterator yielding arg0, arg1, f(arg0, arg1), f(arg1, f(arg0, arg1)), ..</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">arg</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),)</span>
        <span class="k">yield</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>ari(increment: Number, start: Number) -&gt; Iterator</code> which returns the arithmetic series starting at <code>start</code> with the given <code>increment</code>.<ul>
<li>Hint: Use <code>fun()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">ari</span><span class="p">(</span><span class="n">increment</span><span class="p">:</span> <span class="n">Number</span> <span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param increment: any number</span>
<span class="sd">    :param start: any number, starting value</span>
<span class="sd">    :return: the arithmetic series staring at start</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">increment</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>geo(factor: Number, start: Number) -&gt; Iterator</code> which returns the geometric series starting at <code>start</code> with the given <code>factor</code>.<ul>
<li>Hint: Use <code>fun()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">geo</span><span class="p">(</span><span class="n">factor</span><span class="p">:</span> <span class="n">Number</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param factor: any number</span>
<span class="sd">    :param start: any number, starting value</span>
<span class="sd">    :return: the geometric series staring at start</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>fibo()</code> which returns the Fibonacci numbers.<ul>
<li>Hint: Use <code>fun()</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fibo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: iterator yielding the fibonacci series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a class <code>Fibo()</code> which can be used as an Iterable and returns the Fibonacci numbers.<ul>
<li>Hint: Overload <code>__iter__(self)</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Fibo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fibo</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>alternate() -&gt; Iterator</code> which alternates between the arithmetic and geometric series.<ul>
<li>It goes: <code>ari0, geo0, ar1, geo1, ...</code></li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">alternate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ari</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">geo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>hamming(*ps: int) -&gt; Iterator</code> which produces all multiples of <code>p0</code>, <code>p1</code>, <code>p2</code>, ...<ul>
<li>So, hamming(2, 3, 5) yields 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...</li>
<li>Hint: This solution follows Dijkstra: "An exercise attributed to R.W. Hamming":<ul>
<li>Let <code>q</code> be the sequence of multiples produced so far.</li>
<li>Then append <code>min{p*x | x in q, p in ps, p*x &gt; max(q)}</code> to <code>q</code>.</li>
<li>The next number to be produced is <code>min(q)</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="o">*</span><span class="n">ps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param ps: ps = (p0, p1, p2, ..) contains one or more integers, generally primes</span>
<span class="sd">    :return: an iterator yielding all multiples of p0, p1, p2, ..</span>

<span class="sd">    This solution follows Dijkstra: &quot;An exercise attributed to R.W. Hamming&quot;:</span>
<span class="sd">    Let q be the sequence of multiples produced so far.</span>
<span class="sd">    Then append min{p*x | x in q, p in ps, p*x &gt; max(q)} to q.</span>
<span class="sd">    The next number to be produced is min(q)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># q contains all numbers produced so far</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">p</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q</span> <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">mq</span><span class="p">]))</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Exercise-C">Exercise C<a class="anchor-link" href="#Exercise-C"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>skip_duplicates(t: Iterable) -&gt; Iterator</code> which skips successive duplicates of <code>t</code></li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">skip_duplicates</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">    :param t: an iterator</span>
<span class="sd">    :return: an iterator skipping successive duplicates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">last</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">last</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">yield</span> <span class="n">last</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>merge(*ts: Iterable) -&gt; Iterator</code> which merges n non-descending iterators into one.<ul>
<li>Hint: Keep a dictionary <code>heads</code> with key = given iterator <code>t</code> and value = last element read (i.e. head of <code>t</code>)</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param ts: a list of n non-descending iterables, n &gt;= 0</span>
<span class="sd">    :return: merge of n iterables into one</span>
<span class="sd">    This is a weak merge:</span>
<span class="sd">    It doesn&#39;t stop before the longest iterator is exhausted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">]</span>
    <span class="n">heads</span> <span class="o">=</span> <span class="p">{}</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>  <span class="c1"># dictionary of last read entries, initially all None</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># get first element of each iterable if there is one</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">heads</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># try to read next element</span>
                <span class="n">heads</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># get non-exhausted entries</span>
        <span class="n">active_ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span> <span class="k">if</span> <span class="n">heads</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">active_ts</span><span class="p">:</span>  <span class="c1"># no active entry left</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get non-exhausted entry with minimum value</span>
            <span class="n">min_t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">active_ts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">heads</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">heads</span><span class="p">[</span><span class="n">min_t</span><span class="p">]</span>
            <span class="n">heads</span><span class="p">[</span><span class="n">min_t</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be updated on next loop</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a recursive function <code>merge(s, t: Iterable) -&gt; Iterator</code> which merges two non-descending iterators into one.<ul>
<li>Hint: The solution follows exactly the list-based solution. Use <code>chain()</code>.</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">merge1</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param s: a non-descending iterable,</span>
<span class="sd">    :param t: a non-descending iterable,</span>
<span class="sd">    :return: merge of s and t into one</span>
<span class="sd">    This is a weak merge:</span>
<span class="sd">    It doesn&#39;t stop before the longest iterator is exhausted</span>
<span class="sd">    Elegant but inefficient (max recursion depth)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># get iterator from iterable</span>
    <span class="n">head_s</span><span class="p">,</span> <span class="n">head_t</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">take</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># take first element</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">head_s</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">chain</span><span class="p">(</span><span class="n">head_t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># restore first element of t</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">head_t</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">chain</span><span class="p">(</span><span class="n">head_s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="c1"># restore first element of s</span>
    <span class="k">elif</span> <span class="n">head_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">head_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">yield</span> <span class="n">head_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">yield from</span> <span class="n">merge1</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chain</span><span class="p">(</span><span class="n">head_t</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">head_t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">yield from</span> <span class="n">merge1</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">head_s</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>Write a function <code>tee(t: Iterable, n: int) -&gt; Tuple[Iterator]</code> which forks an iterable into n copies to be iterated on independently.<ul>
<li>Hints:<ul>
<li>Keep a list of n deques, one for each fork. This is the buffer.</li>
<li>Each iterator is fed from its deque; you have to fill the deques if they are exhausted. This is <code>itertools.tee</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary data-open="Hide Code" data-close="Show Code"></summary>
        <summary></summary>
        <div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">tee1</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Iterator</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param t: an iterable</span>
<span class="sd">    :param n: number of forks</span>
<span class="sd">    :return: n copies of t, to be iterated on independently</span>
<span class="sd">    This is a remake of itertools.tee</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">(</span><span class="n">q</span><span class="p">:</span> <span class="n">deque</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>  <span class="c1"># when the local deque is empty</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># fetch a new value and</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>  <span class="c1"># load it into buffer</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    {% endraw %}

</div>
 

